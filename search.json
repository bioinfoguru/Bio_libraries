[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bio Libraries",
    "section": "",
    "text": "There are various Python libraries that facilitates analysis of biological data. Here, we’ll learn some of these libraries.\nTo learn more about Bioinformatics learning resources, please visit bioinfo.guru.\nFor any query or feedback related to Python Book, please reach out to the author at manish@bioinfo.guru"
  },
  {
    "objectID": "BioPython_Intro.html",
    "href": "BioPython_Intro.html",
    "title": "1  Working with sequences",
    "section": "",
    "text": "Python offers a variety of functions to work with text data (Strings) that in turn make it easier to work with biological data such as DNA or protein sequences. BioPython library provides a set of classes dedicated to parsing and analysis of different type of biological data. The functions avaiable in BioPython helps researcher to progammatically process the data. Below we’ll see some of the features in Biopython for working with biological data.\nTo install Biopython library run pip install biopython. For more details regarding Biopython installation and tutorials, please refer to the Biopython wiki.\nTo check the version of Biopython, run the following command."
  },
  {
    "objectID": "BioPython_Intro.html#sequence-object",
    "href": "BioPython_Intro.html#sequence-object",
    "title": "1  Working with sequences",
    "section": "1.1 Sequence Object",
    "text": "1.1 Sequence Object\nTo work with sequences, we’ll need the Bio.Seq class which has the required functions for reading and writing sequence data. Once we have imported this class we can create objects having required data. The example below shows constructing a sequence object with a DNA sequence and then using the complement and translate functions to find the sequence of the complementary strand and the translated protein sequence, respectively.\n\nfrom Bio.Seq import Seq\nnew_sequence = Seq('AATTGGAACCTT')\nprint(new_sequence)\nprint(new_sequence.complement())\nprint(new_sequence.translate())\n\nAATTGGAACCTT\nTTAACCTTGGAA\nNWNL\n\n\nTo create a sequence object by reading sequence from a file, we can use the SeqIO class. The parse function in this class can read and write sequences in different formats. This function take two arguments - file name and format, and return an iterator having all the sequences. The code below shows reading a file having multiple sequences and printing the sequences using the seq attribute. Note that this would print sequnces without any annotations. The description attribute of SeqIO object can used to print the description of a sequence as given in the input file. In the code below, the output would be restricted to first three sequences. If you need to print the data for all sequences then remove the if block. The sequence file used in the code below is available here.\n\nfrom Bio import SeqIO\ncount=0\nfor all_seqs in SeqIO.parse(\"kinases.txt\", \"fasta\"):\n    print(all_seqs.description)\n    print(all_seqs.seq)\n    count += 1\n    if(count == 3):\n        break\n\nconsensus seq\nYELLKVL-GKGAFGE--------------------------------------------------------------------V-Y---KAR-D-----------KD-------------------T------G-----E--E--VAVKV----LK-K---G----E-SS----------------K--K-R--K-------------E-------F-LR-EIKI-LKK------L------------------R--------H---PNIVRLYGVF-----------Q-----E-D----------E----D----P----LY--------LVME-YM-------P-GG----SLFD---L---L-R---K--R---R------------------------------------------------------------------------------G-------L-------S-E-------KTLRFIAAQIASGLEYLH-S-K-GI---------IHRDLKPENIL---L--------D--------------------------S------------------D-G-HVKLADF---GL---AR-----------E-----------L-Y----------S---D-------D---------------------------------G-Y--R-------------------T----------T-----T-FVG-T----P-------------------RY--MAPEV--L---------L-------G-------------GG--Y-SKKSDVWSL---GVLLYELLTG---------G--K---P-----P-F------P----G-E-------S---------------NE---E----LL----E-----------KIL------K---------------------G--------------------Y----------------------R---------------------L---P-I-P---E--P----D----C-----S-----P--E---AK---DLIKK--------CLQK-DPEKRPT\nsp|Q22RR1||agc:agc-sar|Tetrahymena sp|Q22RR1||agc:agc-sar|Tetrahymena\nLVYIKEL-GRGNFGS--------------------------------------------------------------------V-N---LVN-E-----------KQ-------------------K------D-----R--L--FAMKV----FI-S---N----Y-IFqr--------------G--I-E--K-------------Y-------I-LR-EKST-LQK------C------------------N--------F---PFIMRYYRSF-----------Y-------D----------N----Y----H----IY--------FMNE-FI-------N-GM----DFFT---V---M-R---E--V---G------------------------------------------------------------------------------L-------F-------N-K-------QQAQFYTAFIILTLQYLN-N-Q-GI---------VYRDLKPENIL---I--------D--------------------------H------------------E-G-WPKLVDM---GT---AK-----------Y-----------L------------Y---D-------Kn--------------------------------Q-Q--L-------------------T----------Rty---S-LVG-T----P-------------------HY--MAPEV--I---------Q-------Q-------------KG--Y-GFAVDIYSL---GVILYELLV----------G--Y---L-----P-Y------Ged--V-D-------D---------------PI---E----VY----Q-----------LIL------E---------------------G-------------------------------------------R---------------------L---G-F-P---N--H----M----K-----N-----R--L---SK---KLISQ--------LMAK-SPEVRLG\nsp|Q234E6||agc:agc-sar|Tetrahymena sp|Q234E6||agc:agc-sar|Tetrahymena\nLIVIKKL-GFGQFGS--------------------------------------------------------------------V-F---LVK-E-----------KG-------------------K------K-----K--L--YGLKC----VS-K---A----Q-VVeq--------------S--L-E--K-------------H-------I-QN-EKQV-MEF------N------------------N--------F---PFVMKFLRSF-----------K-------D----------D----R----C----IY--------FLLE-FI-------Q-GM----ELFD---V---I-R---E--I---G------------------------------------------------------------------------------L-------L-------S-T-------YDSQFYIGSLILTLEYLH-S-N-YI---------IYRDIKPENIM---V--------D--------------------------H------------------A-G-YLKLIDM---GT---AK-----------I-----------M------------K---S-------Ka--------------------------------G-T--V-------------------T----------Rtf---T-IIG-T----P-------------------HY--MAPEV--I---------S-------G-------------KG--Y-NFLVDLWSV---GICLYEFMC----------G--Y---V-----P-F------Aee--A-E-------D---------------PY---E----IY----E-----------EII------K---------------------K-------------------------------------------E---------------------I---Q-F-P---A--Y----M----K-----D-----A--V---AK---QLMLQ--------LLNK-IPEIRLG"
  },
  {
    "objectID": "BioPython_Intro.html#writing-sequences",
    "href": "BioPython_Intro.html#writing-sequences",
    "title": "1  Working with sequences",
    "section": "1.2 Writing sequences",
    "text": "1.2 Writing sequences\nThe write function takes three arguments — 1) a sequence object, 2) filename, and 3) file format. The code below reads a fasta file with multiple sequences and then save the first 10 sequences in a new file.\n\nall_seqs = []\nfor seq_record in SeqIO.parse(\"kinases.txt\", \"fasta\"):\n    all_seqs.append(seq_record)\nprint(len(all_seqs))\n\nSeqIO.write(all_seqs[0:10],\"test.aln\",\"clustal\")\n\n5489\n\n\n10"
  },
  {
    "objectID": "BioPython_Intro.html#multiple-sequence-alignment",
    "href": "BioPython_Intro.html#multiple-sequence-alignment",
    "title": "1  Working with sequences",
    "section": "1.3 Multiple Sequence Alignment",
    "text": "1.3 Multiple Sequence Alignment\nThe AlignIO class has functions to parse alignment files. The read and write functions have a similar syntax to the corresponding functions in the SeqIO class. The alignment object stores sequences in 2D array format such that the rows are number of sequences and columns represent alignment length. To extract a sub-set of an alignment, slicing feature can be used. The code below shows reading an alignment file in fasta format followed by selecting a portion of this alignment and save it in a new file in clustal format. The subset is extracted by giving the range for the rows and columns within square brackets. The numbering for both rows and columns starts from zero. In the example below first ten sequences in the alignment are selected since range of rows is :10 and the colums range is 3:12.\n\nfrom Bio import AlignIO\nalign1 = AlignIO.read(\"kinases.txt\", \"fasta\")\n\n# slicing - [row range, col range]\nx = align1[:10,3:12]\nprint(x)\nAlignIO.write(x,\"msa1.aln\",\"clustal\")\n\nAlignment with 10 rows and 9 columns\nLKVL-GKGA consensus\nIKEL-GRGN sp|Q22RR1||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|Q234E6||agc:agc-sar|Tetrahymena\nVKKL-GNGQ sp|Q23KG5||agc:agc-sar|Tetrahymena\nIKTL-AFGQ sp|Q23DN8||agc:agc-sar|Tetrahymena\nIKKL-GVGQ sp|I7MFS4||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7M3B5||agc:agc-sar|Tetrahymena\nIKKL-GFGQ sp|I7MD55||agc:agc-sar|Tetrahymena\nIKKL-GEGQ sp|Q869J9|pkg-2|agc:pkg|Paramecium\nIRVL-GKGC sp|A8N3F0||agc:agc-unique|Coprinopsis\n\n\n1\n\n\n\n# %load msa1.aln\nCLUSTAL X (1.81) multiple sequence alignment\n\n\nconsensus                           LKVL-GKGA\nsp|Q22RR1||agc:agc-sar|Tetrahy      IKEL-GRGN\nsp|Q234E6||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q23KG5||agc:agc-sar|Tetrahy      VKKL-GNGQ\nsp|Q23DN8||agc:agc-sar|Tetrahy      IKTL-AFGQ\nsp|I7MFS4||agc:agc-sar|Tetrahy      IKKL-GVGQ\nsp|I7M3B5||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|I7MD55||agc:agc-sar|Tetrahy      IKKL-GFGQ\nsp|Q869J9|pkg-2|agc:pkg|Parame      IKKL-GEGQ\nsp|A8N3F0||agc:agc-unique|Copr      IRVL-GKGC"
  },
  {
    "objectID": "BioPython_Intro.html#running-blast-over-the-internet",
    "href": "BioPython_Intro.html#running-blast-over-the-internet",
    "title": "1  Working with sequences",
    "section": "1.4 Running BLAST over the internet",
    "text": "1.4 Running BLAST over the internet\nBiopython offers a functionality to programmatically run BLAST on the NCBI servers using the Bio.Blast class. To run blast online at NCBI servers, Bio.Blast can be used which has different function to run Blast and also to parse the output. The NCBIWWW library has qblast function that takes three arguments &emdash; 1) blast program (blastp, blastn, etc.), 2) database (any of the databases available at NCBI, and 3) sequence. Once the blast serach is over the output can be saved in a file. This output would be in XML format. We can use the read function within the NCBIXML class to parse this output. The code below shows running a blast search using qblast against the non-redundant database available at in NCBI. The output file saved in the previous step has all the hits identified in the Blast search. These hits follow a hierarchical manner such that each result would have multiple alignments and within each alignment would be multiple high scoring pairs (hsps) i.e. Blast object \\(\\longrightarrow\\) Alignment \\(\\longrightarrow\\) hsps. For more details on this you may refer to the Blast documentation available at NCBI.\n\nfrom Bio.Blast import NCBIWWW\nfrom Bio.Blast import NCBIXML\n\nresult_ncbi = NCBIWWW.qblast(\"blastn\", \"nt\", \"8332116\")\n\nwith open(\"my_blast.xml\", \"w\") as file_handle:\n    file_handle.write(result_ncbi.read())\n\n\nresult_handle = open(\"my_blast.xml\")\nblast_record = NCBIXML.read(result_handle)\ncount = 0\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        print(hsp)\n    count += 1\n    if(count==5):\n        break\n\nScore 482 (435 bits), expectation 5.5e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 468 (423 bits), expectation 3.4e-113, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      11 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 600\nScore 443 (400 bits), expectation 3.9e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nScore 441 (398 bits), expectation 1.4e-105, alignment length 593\nQuery:      65 AATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAATT...CTG 655\n               ||||||||| |||  | |  | |||||||||||||||||||    ... ||\nSbjct:     254 AATGGGGAG-GAA--GGATAATTTGGCCATGAAAACTGATCC---...ATG 838\nScore 439 (397 bits), expectation 4.8e-105, alignment length 596\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CTG 655\n               |||||||||||    ||| |||  ||||| |||| |||||||| |...|||\nSbjct:     171 AAAATGGGGAGG---ATGGAGTTTTTGGCTATGAGAACTGATCCA...CTG 757\n\n\nThe hsps object has several attributes including the BLAST statistics such as evalue, score, positives, etc. These can be used to extract hits based on certain conditions. E.g., the code below shows saving hits from the previous Blast search with evalue greater than 1e-105 to a new file.\n\nwith open(\"new_file.txt\", \"w\") as file_handle:\n    for alignment in blast_record.alignments:\n        for hsp in alignment.hsps:\n            if (hsp.expect < 1e-105):\n                print(hsp)\n                file_handle.write(str(hsp)+\"\\n\")\n                file_handle.write(\"\\n\")\nprint(\"DONE\")\n\nScore 482 (435 bits), expectation 5.5e-117, alignment length 624\nQuery:      59 ACAGAAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGA...GTA 678\n               || ||||||||| |||| | |||| ||  |||| |||| | ||||... ||\nSbjct:     278 ACCGAAAATGGGCAGAGGAGTGAATTATATGGCAATGACACCTGA...TTA 901\nScore 468 (423 bits), expectation 3.4e-113, alignment length 590\nQuery:      63 AAAATGGGGAGAGAAATGAAGTACTTGGCCATGAAAACTGATCAA...CCC 649\n               |||||||| |||  |||| | || ||||| |||||||| || |||...|||\nSbjct:      11 AAAATGGGTAGACGAATGGATTATTTGGCGATGAAAACCGAGCAA...CCC 600\nScore 443 (400 bits), expectation 3.9e-106, alignment length 597\nQuery:      87 TTGGCCATGAAAACTGATCAATTGGCCGTGGCTAATATGATCGAT...TAG 679\n               ||||||||||||||||| ||| ||||  |||||||| |||| |||...|||\nSbjct:      25 TTGGCCATGAAAACTGAGCAAATGGCGTTGGCTAATTTGATAGAT...TAG 621\nDONE"
  },
  {
    "objectID": "BioPython_Intro.html#blast-search-using-sequence-file",
    "href": "BioPython_Intro.html#blast-search-using-sequence-file",
    "title": "1  Working with sequences",
    "section": "1.5 BLAST search using sequence file",
    "text": "1.5 BLAST search using sequence file\nTo run the Blast search using a sequence file instead of gi number, we first need to create a seqeunce object and then pass it on to the qblast function as shown below. To run this code, save the protein sequence below in a new file example1.fasta.\nMFHPGMTSQPSTSNQMYYDPLYGAEQIVQCNPMDYHQANILCGMQYFNNSHNRYPLLPQMPPQFTNDHPY DFPNVPTISTLDEASSFNGFLIPSQPSSYNNNNISCVFTPTPCTSSQASSQPPPTPTVNPTPIPPNAGAV LTTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITAVTSNGKQPTGCVTIQRSL DGRLQVAGRKGVPHVVYARIWRWPKVSKNELVKLVQCQTSSDHPDNICINPYHYERVVSNRITSADQSLH VENSPMKSEYLGDAGVIDSCSDWPNTPPDNNFNGGFAPDQPQLVTPIISDIPIDLNQIYVPTPPQLLDNW CSIIYYELDTPIGETFKVSARDHGKVIVDGGMDPHGENEGRLCLGALSNVHRTEASEKARIHIGRGVELT AHADGNISITSNCKIFVRSGYLDYTHGSEYSSKAHRFTPNESSFTVFDIRWAYMQMLRRSRSSNEAVRAQ AAAVAGYAPMSVMPAIMPDSGVDRMRRDFCTIAISFVKAWGDVYQRKTIKETPCWIEVTLHRPLQILDQL LKNSSQFGSS\n\nseq_file = open('example1.fasta')\nresult_handle2 = NCBIWWW.qblast(\"blastp\", \"nr\", seq_file.read())\nseq_file.close()\n\nwith open(\"test_blast.xml\", \"w\") as out_handle:\n    out_handle.write(result_handle2.read())\n\nblast_output = open(\"test_blast.xml\")    \nblast_record = NCBIXML.read(blast_output)\nprint(blast_record.alignments[0])\n\nsp|P45897.1| RecName: Full=Dwarfin sma-4; AltName: Full=MAD protein homolog 3 [Caenorhabditis elegans] >gb|AAA97605.1| SMA-4 [Caenorhabditis elegans]\n           Length = 570\n\n\n\nLet’s say we need only the alignment with the mouse sequence, then, to print first 50 characters of each alignment with the mouse sequence along with corresponding statistics, the following code can be used.\n\nfor alignment in blast_record.alignments:\n    if \"Mus musculus\" in alignment.title:\n        print(alignment.title)\n        for hsp in alignment.hsps:\n            print(hsp.query[0:50])\n            print(hsp.match[0:50])\n            print(hsp.sbjct[0:50])\n            print(hsp.positives, hsp.score, hsp.expect)\n\ngb|KAI2586911.1| SMAD family member 4 [Homo sapiens] >gb|KAI4046350.1| SMAD family member 4 [Homo sapiens] >gb|PNI70022.1| SMAD4 isoform 6 [Pan troglodytes] >gb|PNJ43713.1| SMAD4 isoform 9 [Pongo abelii]\nTAMDSCQQISHVLQCYQQGGEDSDFVRKAIESLVKKLKDKRIELDALITA\nT+ D+C  I H L C++QGGE   F ++AIESLVKKLK+K+ ELD+LITA\nTSNDACLSIVHSLMCHRQGGESETFAKRAIESLVKKLKEKKDELDSLITA\n274 795.0 8.00678e-96\n\n\nTo save the Blast output in csv format, we can use the csv library as shown below.\n\nimport csv\ncsv_out = open(\"blast_out.csv\", \"w\", newline='')\nfor alignment in blast_record.alignments:\n    for hsp in alignment.hsps:\n        new_row = csv.writer(csv_out, delimiter=\",\")\n        new_row.writerow([alignment.title.split(\"|\")[-1], hsp.positives, hsp.expect])\ncsv_out.close()"
  },
  {
    "objectID": "Motif_analysis.html",
    "href": "Motif_analysis.html",
    "title": "2  Motif analysis",
    "section": "",
    "text": "A set of sequences of equal length can be used to create a motif. The create() function in the motifs class takes a list of sequences as an argument to instantiate a motif object.\nThe counts function returns the frequency of each alphabet at all the positions in the motif. Frequency of a particular alphabet at different positions within the motif can also be accessed. The concensus function returns the concensus sequence for the motif.\nTo search a particular motif in a sequence, instances.search function can be used."
  },
  {
    "objectID": "Motif_analysis.html#logomaker",
    "href": "Motif_analysis.html#logomaker",
    "title": "2  Motif analysis",
    "section": "2.1 Logomaker",
    "text": "2.1 Logomaker\nThe logomaker package offers a rich set of functionality to work with sequences/motifs to create sequence logos. It can be installed via pip install logomaker. This library uses pandas and matplotlib to generate sequence logos. The savefig() function of the plt object can be used to save an image of the logo. The resolution of the reulting image can be adjusted using the dpi keyword argument. To draw sequence logo the Logo() function can be used which take the sequence motif in the form of pandas dataframe as an argument.\n\nimport logomaker\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\nss_logo = logomaker.Logo(df_DEAD_motif)\nplt.savefig(\"fig1.png\",dpi=300)\n\n\n\n\nTo normalize the values on the y-axis use normalize() function.\n\nmotif_pwm = motif_DEAD.counts.normalize()\ndf_motif_pwm = pd.DataFrame.from_dict(motif_pwm)\nss_logo_pwm = logomaker.Logo(df_motif_pwm)"
  },
  {
    "objectID": "Motif_analysis.html#decorating-logos",
    "href": "Motif_analysis.html#decorating-logos",
    "title": "2  Motif analysis",
    "section": "2.2 Decorating logos",
    "text": "2.2 Decorating logos\nThe logo fonts can be changed using the font_name argument. Positions within the logo can be highlighted by adding background color as shown below.\n\nss_logo_pwm = logomaker.Logo(df_motif_pwm,font_name='Franklin Gothic Book')\nss_logo_pwm.highlight_position(p=1, color='pink')\nss_logo_pwm.highlight_position(p=2, color='pink')\nss_logo_pwm.highlight_position(p=3, color='pink')\nss_logo_pwm.highlight_position(p=4, color='pink')"
  },
  {
    "objectID": "Motif_analysis.html#reading-motifs",
    "href": "Motif_analysis.html#reading-motifs",
    "title": "2  Motif analysis",
    "section": "2.3 Reading motifs",
    "text": "2.3 Reading motifs\nMotif files such available from Jaspar database can be read directly to create a motif object.\n\ndf_jaspar_motif = pd.DataFrame()\nfh = open(\"MA0007.2.jaspar\")\nfor m in motifs.parse(fh, \"jaspar\"):\n    print(m.counts)\n    df_jaspar_motif = pd.DataFrame.from_dict(m.counts)\nfh.close()\n\n        0      1      2      3      4      5      6      7      8      9     10     11     12     13     14\nA: 6277.00 6497.00   0.00 6462.00 11206.00  26.00 10426.00 1478.00 4353.00 3312.00 3241.00   0.00 2214.00 2656.00 1599.00\nC: 1112.00   0.00   0.00 1304.00   0.00 11115.00   0.00 2976.00 2096.00 3249.00 142.00 525.00 1262.00 2434.00 7032.00\nG: 3049.00 4709.00 11206.00 1254.00   0.00  65.00 107.00 4023.00 2151.00 3291.00 305.00 10681.00 671.00 2460.00 298.00\nT: 768.00   0.00   0.00 2186.00   0.00   0.00 673.00 2729.00 2606.00 1354.00 7518.00   0.00 7059.00 3656.00 2277.00\n\n\n\n\nss_logo = logomaker.Logo(df_jaspar_motif)\n\n\n\n\n\nss_logo = logomaker.Logo(df_jaspar_motif,font_name='Franklin Gothic Book')\nss_logo.highlight_position(p=3, color='magenta')\nss_logo.highlight_position(p=7, color='lightgreen')"
  },
  {
    "objectID": "Phylo.html",
    "href": "Phylo.html",
    "title": "3  Phylogenetic analysis",
    "section": "",
    "text": "One of the frequently used techniques in molecular evolution in phylogenetic analysis. It involves studing the relationship between different organisms based on the similarity between homologous genes. A phylogenetic tree is a pictorial representaion of this relationship. Here we’ll use a set of protein sequences to generate a multiple sequence alignment and then based on the distance (which is inverse of similarity) between different sequences we’ll construct a phylogenetic tree. There are multiple libraries available to do phylogenetic analysis. We’ll use ete3 library which can be installed using the command pip install --upgrade ete3. In addition, to render tree we also need PyQt which can be installed via pip install PyQt5."
  },
  {
    "objectID": "Phylo.html#the-newick-format",
    "href": "Phylo.html#the-newick-format",
    "title": "3  Phylogenetic analysis",
    "section": "3.1 The Newick format",
    "text": "3.1 The Newick format\nOne of the frequently used format for tree representation in Newick format. This is a text based notation of tree structures. In this, nodes are specified as comma separated values within parantheses and ends with a semi-colon. Leaf nodes and internal can have names and branch length can be specified as well. Below are some examples of tree constructed using the Tree() function. The format attribute of this function need to be changed when constructing tree with flexible newick format.\n\nt = Tree( \"((a,b),c);\" )\nprint(t)\n\n\n      /-a\n   /-|\n--|   \\-b\n  |\n   \\-c\n\n\n\n#Tree with internal nodes\nt2 = Tree( \"((a,b)m,c)n;\", format=1 )\nprint(t2)\n\n\n      /-a\n   /-|\n--|   \\-b\n  |\n   \\-c\n\n\nThe show() function generates a graphical representation of the tree and render() function can used to save an image of the tree. This function has keyword attributes to specify resolution, width and height of the image. To show the tree within notebook we call the render() function with %%inline argument.\n\nt.render(\"tree1.png\", dpi=300)\nt.render(\"%%inline\")\n\n\n\n\nTo get the names of all the nodes in a tree we can use traverse() function to interate through the nodes of the tree and print their names. To get a list of only the leaf nodes, get_leaves() can be used.\n\nprint([n.name for n in t2.traverse()])\nprint([x.name for x in t2.get_leaves()])\n\n['n', 'm', 'c', 'a', 'b']\n['a', 'b', 'c']"
  },
  {
    "objectID": "Phylo.html#loading-free-from-a-file",
    "href": "Phylo.html#loading-free-from-a-file",
    "title": "3  Phylogenetic analysis",
    "section": "3.2 Loading free from a file",
    "text": "3.2 Loading free from a file\nWe can create a tree object by loading a tree in newick format. In this example we’ll use a phylogenetic tree generated after multiple sequence alignment of protein sequences using the MUSCLE program.\n\ndhfr_tree = Tree('dhfr_20.tree')\n\n\nprint(dhfr_tree)\n\n\n                              /-sp|P37508|YYAP_BACSU\n                           /-|\n                        /-|   \\-sp|Q04515|DYR10_ECOLX\n                       |  |\n                     /-|   \\-sp|Q5V3R2|DYR1_HALMA\n                    |  |\n                  /-|   \\-sp|Q93341|DYR_CAEEL\n                 |  |\n                 |  |   /-sp|P46103|DRTS_PLAVN\n               /-|   \\-|\n              |  |      \\-sp|G4VJD6|DYR_SCHMA\n              |  |\n            /-|   \\-sp|P22906|DYR_CANAX\n           |  |\n           |  |   /-sp|Q9U8B8|DYR_HELVI\n           |   \\-|\n         /-|     |   /-sp|P28019|DYR_AEDAL\n        |  |      \\-|\n        |  |         \\-sp|P17719|DYR_DROME\n      /-|  |\n     |  |   \\-sp|P00378|DYR_CHICK\n     |  |\n     |  |   /-sp|P27421|DYR_SHV24\n   /-|   \\-|\n  |  |      \\-sp|P09503|DYR_SHV21\n  |  |\n  |  |   /-sp|Q86XF0|DYR2_HUMAN\n  |   \\-|\n  |      \\-sp|P00374|DYR_HUMAN\n--|\n  |   /-sp|P00376|DYR_BOVIN\n  |--|\n  |   \\-sp|P00377|DYR_PIG\n  |\n  |   /-sp|P04753|DYR_MESAU\n   \\-|\n     |   /-sp|Q920D2|DYR_RAT\n      \\-|\n         \\-sp|P00375|DYR_MOUSE\n\n\n\ndhfr_tree.render(\"%%inline\")"
  },
  {
    "objectID": "Phylo.html#decorating-trees",
    "href": "Phylo.html#decorating-trees",
    "title": "3  Phylogenetic analysis",
    "section": "3.3 Decorating trees",
    "text": "3.3 Decorating trees\nThere are function available to add style to the nodes and branches of a tree to highlight specific aspects of the phylogenetic relationship. For example, to highlight a particular clade within the tree, we can add a background color. We can also alter the layout of the tree using the functions available in the TreeStyle class. Similarly, nodes can be customized using NodeStyle.\n\nfrom ete3 import TreeStyle\nts = TreeStyle()\nts.show_leaf_name = True\nts.rotation = 90\ndhfr_tree.render(\"%%inline\",tree_style=ts)\n\n\n\n\n\n#Circular layout\ncircular_style = TreeStyle()\ncircular_style.mode = \"c\" \ndhfr_tree.render(\"%%inline\", tree_style=circular_style)\n\n\n\n\n\nQuiz: Write a code to generate a phylogenetic tree in a semi-circular layout (as shown below).\n\n\n\n\n\n\n\n\nShow answer\n#semi-circular layout\ncircular_style.arc_start = -180 \ncircular_style.arc_span = 180\ndhfr_tree.render(\"%%inline\", tree_style=circular_style)\n\n\nThe node within a tree can be highlighted by changing the text color or the background color.\n\nfrom ete3 import Tree, faces, AttrFace, TreeStyle, NodeStyle\nnst1 = NodeStyle()\nnst1[\"bgcolor\"] = \"LightSteelBlue\"\nnst2 = NodeStyle()\nnst2[\"bgcolor\"] = \"DarkSeaGreen\"\nn1 = dhfr_tree.get_common_ancestor(\"sp|Q86XF0|DYR2_HUMAN\", \"sp|P00374|DYR_HUMAN\")\nn1.set_style(nst1)\nn2 = dhfr_tree.get_common_ancestor(\"sp|Q04515|DYR10_ECOLX\", \"sp|P22906|DYR_CANAX\")\nn2.set_style(nst2)\n\ndhfr_tree.render(\"%%inline\", tree_style=circular_style)"
  },
  {
    "objectID": "Phylo.html#adding-sequence-alignment-to-tree",
    "href": "Phylo.html#adding-sequence-alignment-to-tree",
    "title": "3  Phylogenetic analysis",
    "section": "3.4 Adding sequence alignment to tree",
    "text": "3.4 Adding sequence alignment to tree\nFor situations where we would like to show sequence alignment (or a subset of alignment) along with the phylogenetic tree, we can use PhyloTree class. Here, instead of contructing an object of class Tree, the tree in instantiated as an object of the class PhyloTree. This allow to attach a multiple sequence alignment to the phylogenetic tree.\n\nfrom ete3 import PhyloTree\n\n\nalign_tree2 = PhyloTree(\"( HBAZ_CAPHI:0.36620, HBA_HUMAN:0.07042, HBA_MOUSE:0.07042);\")\n\n\nalign_txt = '''\n>HBAZ_CAPHI\nMSLTRTERTIILSLWSKISTQADVIGTETLERLFSCYPQAKTYFPHFDLHSGSAQLRAHG\nSKVVAAVGDAVKSIDNVTSALSKLSELHAYVLRVDPVNFKFLSHCLLVTLASHFPADFTA\nDAHAAWDKFLSIVSGVLTEKYR\n>HBA_HUMAN\nMVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHG\nKKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTP\nAVHASLDKFLASVSTVLTSKYR\n>HBA_MOUSE\nMVLSGEDKSNIKAAWGKIGGHGAEYGAEALERMFASFPTTKTYFPHFDVSHGSAQVKGHG\nKKVADALASAAGHLDDLPGALSALSDLHAHKLRVDPVNFKLLSHCLLVTLASHHPADFTP\nAVHASLDKFLASVSTVLTSKYR\n'''\n\n\nalign_tree2.link_to_alignment(alignment=align_txt, alg_format=\"fasta\")\n\n\nprint(align_tree2)\nalign_tree2.render(\"%%inline\")\n#align_tree2.render(file_name=\"tree_align.png\", dpi=300)\n\n\n   /-HBAZ_CAPHI\n  |\n--|--HBA_HUMAN\n  |\n   \\-HBA_MOUSE"
  },
  {
    "objectID": "BIO_PDB.html",
    "href": "BIO_PDB.html",
    "title": "4  Working with structures",
    "section": "",
    "text": "Biomolecular structures can be saved in different formats such as PDB, mmCIF, XML, etc. The PDB format is the most common format and is supported by all visualization and docking programs. In this format the annotations for the structure are stored as different tags such as TITLE, COMPND, SOURCE, REMARK, etc. The atomic coordinates are saved under ATOM and HETATM tags. The PDB class of Bio library has a PDBParser() function to instantiate a PDB parser object which can be used to read and write structure files in pdb format. The get_structure function takes two arguments — a name for the new structure object and a pdb file name.\n\n\n    ...ANNOTATIONS...\n\nHEADER    VIRAL PROTEIN                           18-AUG-20   7JTL              \nTITLE     STRUCTURE OF SARS-COV-2 ORF8 ACCESSORY PROTEIN                        \nCOMPND    MOL_ID: 1;                                                            \nCOMPND   2 MOLECULE: ORF8 PROTEIN;                                              \nCOMPND   3 CHAIN: A, B;                                                         \nCOMPND   4 SYNONYM: ORF8, NON-STRUCTURAL PROTEIN 8, NS8;                        \nCOMPND   5 ENGINEERED: YES                                                      \nSOURCE    MOL_ID: 1;                                                            \nSOURCE   2 ORGANISM_SCIENTIFIC: SEVERE ACUTE RESPIRATORY SYNDROME CORONAVIRUS   \nSOURCE   3 2;                                                                   \n\n    ...ATOM RECORDS...\n\nATOM      1  N   GLN A  18      40.917  33.173 126.601  1.00 73.92           N  \nATOM      2  CA  GLN A  18      42.025  33.162 125.645  1.00 73.89           C  \nATOM      3  C   GLN A  18      41.754  32.204 124.493  1.00 67.88           C  \nATOM      4  O   GLN A  18      42.414  31.177 124.374  1.00 66.48           O  \nATOM      5  CB  GLN A  18      43.339  32.782 126.337  1.00 73.82           C  \nATOM      6  N   GLU A  19      40.764  32.527 123.665  1.00 60.90           N  \nATOM      7  CA  GLU A  19      40.434  31.695 122.517  1.00 50.80           C  \nATOM      8  C   GLU A  19      40.928  32.273 121.201  1.00 50.81           C  \nATOM      9  O   GLU A  19      41.122  31.517 120.240  1.00 47.32           O  \nATOM     10  CB  GLU A  19      38.918  31.467 122.431  1.00 55.27           C  \n\n\n\nfrom Bio.PDB import *\nstructure = PDBParser().get_structure(\"Protease\", \"7jtl.pdb\")\n\nThe structure object has a attribute header that stores the annotations for the structure as a dictionary.\n\nprint(\"The structure title is:\",structure.header[\"name\"])\nprint(\"The structure resolution is:\",structure.header[\"resolution\"])\nprint(\"The structure keywords are:\",structure.header[\"keywords\"])\n\nThe structure title is: structure of sars-cov-2 orf8 accessory protein\nThe structure resolution is: 2.04\nThe structure keywords are: sars-cov-2, sars2, covid-19, coronavirus, accessory protein, host- factor restriction, rna virus, immune evasion, mhc-i, open reading frame 8, viral protein\n\n\nThe coordinates in the structure object has a hierarchical organization as shown in the diagram below. The structure object is at the top of the hierarchy which has one or more models. Each model can have one or more chains; and so on. This organization, in programming terms, can be thought of as a nested list. To navigate through the structure object we can either use for loop or some of the available in-built functions. The later being computationally efficient choice. The objects at each level in this organization has dedicated functions and attribute to get more information about the level.\n\n\n\n\n\nIterating the hierarchical organization using tandem for loops. The code below creates a dictionary having chain names as keys and a list of residues in that chain as values.\n\nimport collections\nchain_residues = collections.defaultdict(list)\nfor model in structure:\n    for chain in model:\n        for residue in chain:\n            if(residue.resname != 'HOH'):\n                chain_residues[chain.id].append(residue.resname)\nprint(chain_residues)\n\ndefaultdict(<class 'list'>, {'A': ['GLN', 'GLU', 'CYS', 'SER', 'LEU', 'GLN', 'SER', 'CYS', 'THR', 'GLN', 'HIS', 'GLN', 'PRO', 'TYR', 'VAL', 'VAL', 'ASP', 'ASP', 'PRO', 'CYS', 'PRO', 'ILE', 'HIS', 'PHE', 'TYR', 'SER', 'LYS', 'TRP', 'TYR', 'ILE', 'ARG', 'VAL', 'GLY', 'ALA', 'ARG', 'LYS', 'SER', 'ALA', 'PRO', 'LEU', 'ILE', 'GLU', 'LEU', 'CYS', 'VAL', 'ASP', 'GLU', 'SER', 'LYS', 'SER', 'PRO', 'ILE', 'GLN', 'TYR', 'ILE', 'ASP', 'ILE', 'GLY', 'ASN', 'TYR', 'THR', 'VAL', 'SER', 'CYS', 'LEU', 'PRO', 'PHE', 'THR', 'ILE', 'ASN', 'CYS', 'GLN', 'GLU', 'PRO', 'LYS', 'LEU', 'GLY', 'SER', 'LEU', 'VAL', 'VAL', 'ARG', 'CYS', 'SER', 'PHE', 'TYR', 'GLU', 'ASP', 'PHE', 'LEU', 'GLU', 'TYR', 'HIS', 'ASP', 'VAL', 'ARG', 'VAL', 'VAL', 'LEU', 'ASP', 'PHE', 'ILE', 'NA'], 'B': ['GLN', 'GLU', 'CYS', 'SER', 'LEU', 'GLN', 'SER', 'CYS', 'THR', 'GLN', 'HIS', 'GLN', 'PRO', 'TYR', 'VAL', 'VAL', 'ASP', 'ASP', 'PRO', 'CYS', 'PRO', 'ILE', 'HIS', 'PHE', 'TYR', 'SER', 'LYS', 'TRP', 'TYR', 'ILE', 'ARG', 'VAL', 'GLY', 'ALA', 'ARG', 'LYS', 'SER', 'ALA', 'PRO', 'LEU', 'ILE', 'GLU', 'LEU', 'CYS', 'VAL', 'ASP', 'GLU', 'ALA', 'SER', 'PRO', 'ILE', 'GLN', 'TYR', 'ILE', 'ASP', 'ILE', 'GLY', 'ASN', 'TYR', 'THR', 'VAL', 'SER', 'CYS', 'LEU', 'PRO', 'PHE', 'THR', 'ILE', 'ASN', 'CYS', 'GLN', 'GLU', 'PRO', 'LYS', 'LEU', 'GLY', 'SER', 'LEU', 'VAL', 'VAL', 'ARG', 'CYS', 'SER', 'PHE', 'TYR', 'GLU', 'ASP', 'PHE', 'LEU', 'GLU', 'TYR', 'HIS', 'ASP', 'VAL', 'ARG', 'VAL', 'VAL', 'LEU', 'ASP', 'PHE', 'ILE']})\n\n\nThe Selection module in Bio.PDB has unfold_entities function that facilitates navigation through different levels in the structure object. This function takes two arguments – an entity list and the target level. The targen level is a single letter code via Atom, Residue, Chain, Model, or Structure. E.g. we can get all the atoms in a structure object using Selection.unfold_entities(structure, 'A'). The diagram below shows the different arguments for the unfold_entities function to unpack at different levels starting at the structure level. Note that structure here refers to the name of the structure object instantiated using PDBParser().\n\n\n\n\n\n\nQuiz: Write a code to get a dictionary having chain names as keys and a list of residues in that chain as values using unfold_entities().\n\n\n\nShow answer\nchain_residues2 = collections.defaultdict(list)\nresidues_all = Selection.unfold_entities(structure,\"R\")\n[chain_residues2[r1.get_parent().id].append(r1.resname)\\\n for r1 in residues_all if r1.resname != 'HOH']\nprint(chain_residues2)"
  },
  {
    "objectID": "BIO_PDB.html#sequence-from-pdb-file",
    "href": "BIO_PDB.html#sequence-from-pdb-file",
    "title": "4  Working with structures",
    "section": "4.1 Sequence from pdb file",
    "text": "4.1 Sequence from pdb file\nThe parse function in the Bio.SeqIO module can be used to retrive the sequences of polymers in the pdb file. There are two different types of sequences that can be retrieved. 1) sequence from the ATOM record and 2) sequence from the SEQRES record (if present). The residues which are disordered in the structure would not appear in the sequence retrived using the pdb-atom argument while those residues would be there in the output with pdb-seqres argument.\n\n%%capture --no-stdout\nfrom Bio import SeqIO\nfor record in SeqIO.parse(\"7jtl.pdb\", \"pdb-atom\"):\n    print(\"Chain\", record.annotations[\"chain\"])\n    print(record.seq)\n\nChain A\nQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEXXSKSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI\nChain B\nQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEAXXXSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI\n\n\n\nfrom Bio import SeqIO\nfor record in SeqIO.parse(\"7jtl.pdb\", \"pdb-seqres\"):\n    print(\"Chain\", record.annotations[\"chain\"])\n    print(record.seq)\n\nChain A\nSNAQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEAGSKSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI\nChain B\nSNAQECSLQSCTQHQPYVVDDPCPIHFYSKWYIRVGARKSAPLIELCVDEAGSKSPIQYIDIGNYTVSCLPFTINCQEPKLGSLVVRCSFYEDFLEYHDVRVVLDFI\n\n\n\nThe residue object\nTo get a list of residues within an object at any level above residue, we can use the get_residue function. To get the residue name and id for a particular residue, resname and id attributes for the residue object can be used. The get_parent function returns the corresponding chain for a residue object. The get_list function for the residue object return a list having all the atoms within that residue.\n\nctr=0\nprot_seq=\"\"\nfor residue in model.get_residues():\n    if(ctr==5):\n        break\n    print(residue.resname, residue.id[1])\n    prot_seq+=residue.resname\n    ctr+=1\nprint(prot_seq)\n\nGLN 18\nGLU 19\nCYS 20\nSER 21\nLEU 22\nGLNGLUCYSSERLEU\n\n\nTo convert the sequence in three letter code to single letter code, we can use SeqUtils package available in biopython. The seq1() function returns single letter sequence for a three letter sequence. Similarly, to convert single letter sequence to three letter we have seq3() function.\n\nfrom Bio.SeqUtils import seq1\nseq1(prot_seq)\n\n'QECSL'\n\n\nIn case the structure has some modified residues then custom mapping of three letter code to single letter code can be done using the custom_map keyword argument to seq1() function. E.g., let say a protein has a phosphorylated serine residue for which the three letter code is SEP and there is no standard single letter code for this. We can add custom mapping for SEP to S as follows.\n\nprot_seq+=\"SEP\"\nprint(seq1(prot_seq)) #without custom map\nprint(seq1(prot_seq,custom_map={\"SEP\": \"S\"}))\n\nQECSLX\nQECSLS"
  },
  {
    "objectID": "BIO_PDB.html#atom-object",
    "href": "BIO_PDB.html#atom-object",
    "title": "4  Working with structures",
    "section": "4.2 Atom object",
    "text": "4.2 Atom object\nThe information within an atom object can be accessed using different functions specific of a particular property. E.g., to get the name and coordinates for an atom, get_name and get_coord functions can be used. Similarly, to modify a value for any property, functions with set_ prefix can be used.\n\nres_list = list(structure[0][\"A\"].get_residues())\nprint(res_list[3])\natoms_resi3 = res_list[3].get_list()\nprint(atoms_resi3)\nprint(atoms_resi3[1].get_coord())\n\n<Residue SER het=  resseq=21 icode= >\n[<Atom N>, <Atom CA>, <Atom C>, <Atom O>, <Atom CB>, <Atom OG>]\n[ 44.851  36.104 119.41 ]"
  },
  {
    "objectID": "BIO_PDB.html#distance-calculations",
    "href": "BIO_PDB.html#distance-calculations",
    "title": "4  Working with structures",
    "section": "4.3 Distance Calculations",
    "text": "4.3 Distance Calculations\nThe distance between any two atoms can be easily calculated using the - operator.\n\nca_3 = res_list[3].get_list()[1]\nca_15 = res_list[15].get_list()[1]\ndistance = ca_3 - ca_15 # distance between two atoms\nprint(distance)\n\n10.335114\n\n\n\nCalulating Ca-Ca distance matrix\nC-alpha distance matrix is a visual tool to analyze intra-molecular interactions in a protein structure. This matix has pairwise distances for all Ca atoms. The distance matrix can be converted to a contact map using a distance threshold.\n\nfrom scipy.spatial.distance import squareform\nimport matplotlib.pyplot as plt\n\natom_list = Selection.unfold_entities(structure, \"A\")\nca_ca_dist = []\nca_atom_list = [x for x in atom_list if \"CA\" in x.name]\nfor x in range(len(ca_atom_list)):\n    for y in range(x + 1,len(ca_atom_list)):\n        ca_ca_dist.append(ca_atom_list[x]-ca_atom_list[y])\ndist_mat = squareform(ca_ca_dist)\n## calculate contact map\ncont_map = dist_mat.copy()\ncont_map[cont_map>7]=0\n\n\nfig, ax = plt.subplots(1,2, sharey=True)\na = ax[0].imshow(dist_mat, cmap=\"YlGn\")\nax[0].set_title(\"Distance Map\")\nb = ax[1].imshow(cont_map, cmap=\"YlGn\")\nax[1].set_title(\"Contact Map\")\nfig.colorbar(a, ax=ax[0], shrink=0.5, label=\"Distance ($\\AA$)\")\nfig.colorbar(b, ax=ax[1], shrink=0.5, label=\"Distance ($\\AA$)\")\nplt.show()"
  },
  {
    "objectID": "BIO_PDB.html#interface-residues",
    "href": "BIO_PDB.html#interface-residues",
    "title": "4  Working with structures",
    "section": "4.4 Interface residues",
    "text": "4.4 Interface residues\nThe Bio.PDB has NeighborSearch function that is useful for calculating neighboring residues for a given selection of atoms. This function can be used to find interface residues in a multimeric complex. For this, we first need to define atoms selections having atoms for each of the monomeric subunits. Then we need to call this functions for each subunit to get the surrounding residues for both the subunits.\n\nA_atoms = Selection.unfold_entities(structure[0][\"A\"], \"A\")\nB_atoms = Selection.unfold_entities(structure[0][\"B\"], \"A\")\n\nSearch atoms around chain A.\n\nns = NeighborSearch(A_atoms)\ncontacts_B = []\nfor atom in B_atoms:\n    close_atoms = ns.search(atom.coord, 3)\n    if len(close_atoms)>0:\n        for a in close_atoms:\n            contacts_B.append(a.get_parent().get_id()[1])\nprint(\"Residues of chain B around chain A are:\")\nprint(', '.join(map(str, contacts_B)))\n\nResidues of chain B around chain A are:\n314, 20, 339, 120, 120, 24, 118, 119, 307, 115, 115, 341, 51, 53, 119, 115, 310, 358, 349, 387, 387, 201, 403\n\n\nSearch atoms around chain B.\n\nns = NeighborSearch(B_atoms)\n\ncontacts_A = []\nfor atom in A_atoms:\n    close_atoms = ns.search(atom.coord, 3)\n    if len(close_atoms)>0:\n        for a in close_atoms:\n            contacts_A.append(a.get_parent().get_id()[1])\nprint(\"Residues of chain A around chain B are:\")\nprint(', '.join(map(str, contacts_A)))\n\nResidues of chain A around chain B are:\n20, 53, 120, 120, 118, 119, 214, 115, 115, 213, 51, 53, 287, 115, 262, 18, 50, 119, 275, 272, 285, 282, 290"
  },
  {
    "objectID": "BIO_PDB.html#binana",
    "href": "BIO_PDB.html#binana",
    "title": "4  Working with structures",
    "section": "4.5 Binana",
    "text": "4.5 Binana\nBINANA (BINding ANAlyzer) is a python library that can be used for protein-ligand binding analysis. The tool is of particular use when analyzing protein-ligand docking results. The source code is available for download. After download the file, unzip the archive and add the path of the location where binana is there to sys.path as shown below. You should now be able to import binana.\n\nimport sys\nsys.path.append(\"<fullpath>/binana-2.1/python/\")\nimport binana\n\nThe first thing that we need to do is to load the receptor and the ligand files. Once we have the these two files as binana objects we can proceed with interaction analysis. The interactions class has a set of functions for retriving different types of inter-molecular interactions. E.g., getting a list of hydrogen bonds between the receptor and the ligand using get_hydrogen_bonds(). This function returns a dictionary having information about each hydrogen bond between the receptor and the ligand. Similarly, we can get information about all types of intermolecular interactions (including hydrogen bonding) using get_all_interactions function.\n\nligand, receptor = binana.load_ligand_receptor.from_files(\"<fullpath>/binana-2.1/python/example/ligand.pdbqt\", \\\n                                                          \"<fullpath>/binana-2.1/python/example/receptor.pdbqt\")\nhbond_inf = binana.interactions.get_hydrogen_bonds(ligand, receptor)\nfor hbond_label in hbond_inf[\"labels\"]:\n    print(hbond_label)\n\n\n\n\n('A:CHT(1):N1(14)', 'A:CHT(1):H1(16)', 'A:ASP(157):OD2(285)', 'LIGAND', {'distance': 2.6500811308335455, 'angle': 16.087842801376098})\n('A:CHT(1):O6(22)', 'A:ASN(156):2HD2(276)', 'A:ASN(156):ND2(274)', 'RECEPTOR', {'distance': 2.9006795755477723, 'angle': 35.51562311681741})\n\n\n\nall_inf = binana.interactions.get_all_interactions(ligand, receptor) \nall_inf.keys()\nall_inf[\"hydrogen_bonds\"]\n\n\n#delete\nall_inf.keys()\n\ndict_keys(['closest', 'close', 'electrostatic_energies', 'active_site_flexibility', 'hydrophobics', 'hydrogen_bonds', 'halogen_bonds', 'ligand_atom_types', 'pi_pi', 'cat_pi', 'salt_bridges', 'metal_coordinations', 'ligand_rotatable_bonds'])\n\n\n\nall_data = binana.output.dictionary.collect_all(all_inf)\n\n\nprint(len(all_data[\"hydrogenBonds\"]))\nfor x in all_data[\"hydrogenBonds\"]:\n    print(x)\n\n2\n{'ligandAtoms': [{'chain': 'A', 'resID': 1, 'resName': 'CHT', 'atomName': 'N1', 'atomIndex': 14}, {'chain': 'A', 'resID': 1, 'resName': 'CHT', 'atomName': 'H1', 'atomIndex': 16}], 'receptorAtoms': [{'chain': 'A', 'resID': 157, 'resName': 'ASP', 'atomName': 'OD2', 'atomIndex': 285}], 'metrics': {'distance': 2.6500811308335455, 'angle': 16.087842801376098}}\n{'ligandAtoms': [{'chain': 'A', 'resID': 1, 'resName': 'CHT', 'atomName': 'O6', 'atomIndex': 22}], 'receptorAtoms': [{'chain': 'A', 'resID': 156, 'resName': 'ASN', 'atomName': 'ND2', 'atomIndex': 274}, {'chain': 'A', 'resID': 156, 'resName': 'ASN', 'atomName': '2HD2', 'atomIndex': 276}], 'metrics': {'distance': 2.9006795755477723, 'angle': 35.51562311681741}}"
  }
]